(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{74:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return o})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return c}));var r=t(2),a=t(6),i=(t(0),t(114)),s={slug:"flutter-recipes-2-firebase-firestore-helpers",title:"Flutter Recipes 2 - Firebase Firestore Helpers",author:"Damodar Lohani",author_title:"Web and Mobile Developer",author_url:"https://github.com/lohanidamodar",author_image_url:"https://avatars1.githubusercontent.com/u/6360216?s=460&u=ccf757cc3aece5b674460c4909b4a77e1d5b6a19&v=4",tags:["flutter"]},o={permalink:"/blog/flutter-recipes-2-firebase-firestore-helpers",editUrl:"https://github.com/lohanidamodar/dlohani.com.np/edit/master/website/blog/blog/2020-10-24-flutter-recipes-2.md",source:"@site/blog/2020-10-24-flutter-recipes-2.md",description:"I have built quite a few apps with Flutter and Firebase. And, for most of those projects I used Firestore as the database. So, I had to perform all sorts of query, pagination, mapping Firestore returned Maps to data models. So over that period of time, I have created a simplified, generalized helper class with various methods that help me work with firestore database. That is what I am publishing here. Hope it will be useful for those using firestore in their database.",date:"2020-10-24T00:00:00.000Z",tags:[{label:"flutter",permalink:"/blog/tags/flutter"}],title:"Flutter Recipes 2 - Firebase Firestore Helpers",readingTime:8.81,truncated:!0,prevItem:{title:"Singleton Pattern in Dart",permalink:"/blog/singleton-in-dart"},nextItem:{title:"Flutter URL Preview",permalink:"/blog/flutter-url-preview"}},l=[{value:"The Source Code",id:"the-source-code",children:[]},{value:"Adding Dependency and importing",id:"adding-dependency-and-importing",children:[]},{value:"Create a model",id:"create-a-model",children:[]},{value:"Instiantiate database service with specific type",id:"instiantiate-database-service-with-specific-type",children:[]},{value:"Insert new item to firestore",id:"insert-new-item-to-firestore",children:[]},{value:"Github Repository",id:"github-repository",children:[]}],d={rightToc:l};function c(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"I have built quite a few apps with Flutter and Firebase. And, for most of those projects I used Firestore as the database. So, I had to perform all sorts of query, pagination, mapping Firestore returned Maps to data models. So over that period of time, I have created a simplified, generalized helper class with various methods that help me work with firestore database. That is what I am publishing here. Hope it will be useful for those using firestore in their database."),Object(i.b)("h2",{id:"the-source-code"},"The Source Code"),Object(i.b)("p",null,"This class has the most commonly used methods on firestore. It can get list of items from collection, single item, remove item, add item. It provides list and single item both as a future and stream. It also provides methods for easier query and simple paginations. It uses generic type so that, we can use it to convert firestore map to the required data model we want. This class is available as a part of ",Object(i.b)("inlineCode",{parentName:"p"},"firebase_helpers")," package."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-dart"}),'\n/// The base database service class that you can instiantiate or extend\n///\n/// ```dart\n/// DatabaseService<Note> noteDBs = DatabaseService<Note>("notes",fromDS: (id,data) => Note.fromDS(id,data), toMap: (note)=>note.toMap());\n/// noteDBs.getQueryList()\n///   .then((List<Note> notes)=>print(notes));\n/// ```\n///\nclass DatabaseService<T> {\n  /// path of the collection to use as base path for all the operations\n  String collection;\n\n  final FirebaseFirestore _db = FirebaseFirestore.instance;\n\n  ///\n  /// Function to convert the firestore [DocumentSnapshot] into the model class [T]\n  /// provides [id] and [Map<String,dynamic> data] and must return [T] object.\n  ///\n  final T Function(String, Map<String, dynamic>) fromDS;\n\n  ///\n  ///Function to convert object [T] to [Map<String,dynamic>], receives instance of [T],\n  ///and should always return [Map<String,dynamic>]\n  ///\n  final Map<String, dynamic> Function(T) toMap;\n\n  /// Create instance of Database service\n  /// [collection] path is required\n  /// [fromDS] is required to get document snapshot as object [T]\n  ///\n  DatabaseService(this.collection, {this.fromDS, this.toMap});\n\n  /// Returns instance of FirebaseFirestore\n  FirebaseFirestore get db => _db;\n\n  /// Get a single document of [id] from the [collection]\n  /// Returns null if the document does not exist\n  Future<T> getSingle(String id) async {\n    var snap = await _db.collection(collection).doc(id).get();\n    if (!snap.exists) return null;\n    return fromDS(snap.id, snap.data());\n  }\n\n  /// Returns a single document of [id] from [collection]\n  /// as stream so that updates can be listened\n  Stream<T> streamSingle(String id) {\n    return _db\n        .collection(collection)\n        .doc(id)\n        .snapshots()\n        .map((snap) => snap.exists ? fromDS(snap.id, snap.data()) : null);\n  }\n\n  /// Returns list of all the documents from [collection]\n  /// as a stream so that changes can be listened\n  Stream<List<T>> streamList() {\n    var ref = _db.collection(collection);\n    return ref.snapshots().map(\n        (list) => list.docs.map((doc) => fromDS(doc.id, doc.data())).toList());\n  }\n\n  /// Returns the list of documents from [collection], in the order provided in\n  /// [orderBy] and matches the [args] supplied.\n  /// use [startAfter], [startAt], [endAt], [endBefore] to perform cursor based queries\n  /// and pagination of data\n  Future<List<T>> getQueryList({\n    List<OrderBy> orderBy,\n    List<QueryArgs> args,\n    int limit,\n    dynamic startAfter,\n    dynamic startAt,\n    dynamic endAt,\n    dynamic endBefore,\n  }) async {\n    CollectionReference collref = _db.collection(collection);\n    Query ref;\n    if (args != null) {\n      for (final arg in args) {\n        if (arg is QueryArgsV2) {\n          if (ref == null)\n            ref = collref.where(\n              arg.key,\n              isEqualTo: arg.isEqualTo,\n              isGreaterThan: arg.isGreaterThan,\n              isGreaterThanOrEqualTo: arg.isGreaterThanOrEqualTo,\n              isLessThan: arg.isLessThan,\n              isLessThanOrEqualTo: arg.isLessThanOrEqualTo,\n              isNull: arg.isNull,\n              arrayContains: arg.arrayContains,\n              arrayContainsAny: arg.arrayContainsAny,\n              whereIn: arg.whereIn,\n            );\n          else\n            ref = ref.where(\n              arg.key,\n              isEqualTo: arg.isEqualTo,\n              isGreaterThan: arg.isGreaterThan,\n              isGreaterThanOrEqualTo: arg.isGreaterThanOrEqualTo,\n              isLessThan: arg.isLessThan,\n              isLessThanOrEqualTo: arg.isLessThanOrEqualTo,\n              isNull: arg.isNull,\n              arrayContains: arg.arrayContains,\n              arrayContainsAny: arg.arrayContainsAny,\n              whereIn: arg.whereIn,\n            );\n          ;\n        } else {\n          if (ref == null)\n            ref = collref.where(arg.key, isEqualTo: arg.value);\n          else\n            ref = ref.where(arg.key, isEqualTo: arg.value);\n        }\n      }\n    }\n    if (orderBy != null) {\n      orderBy.forEach((order) {\n        if (ref == null)\n          ref = collref.orderBy(order.field, descending: order.descending);\n        else\n          ref = ref.orderBy(order.field, descending: order.descending);\n      });\n    }\n    if (limit != null) {\n      if (ref == null)\n        ref = collref.limit(limit);\n      else\n        ref = ref.limit(limit);\n    }\n    if (startAfter != null && orderBy != null) {\n      ref = ref.startAfter([startAfter]);\n    }\n    if (startAt != null && orderBy != null) {\n      ref = ref.startAt([startAt]);\n    }\n    if (endAt != null && orderBy != null) {\n      ref = ref.endAt([endAt]);\n    }\n    if (endBefore != null && orderBy != null) {\n      ref = ref.endBefore([endBefore]);\n    }\n    QuerySnapshot query;\n    if (ref != null)\n      query = await ref.get();\n    else\n      query = await collref.get();\n\n    return query.docs.map((doc) => fromDS(doc.id, doc.data())).toList();\n  }\n\n  /// Returns the list of documents from [collection], in the order provided in\n  /// [orderBy] and matches the [args] supplied as a stream so that changes can be\n  /// listened.\n  /// Use [startAfter], [startAt], [endAt], [endBefore] to perform cursor based\n  /// queries and pagination of data\n  Stream<List<T>> streamQueryList({\n    List<OrderBy> orderBy,\n    List<QueryArgs> args,\n    int limit,\n    dynamic startAfter,\n    dynamic startAt,\n    dynamic endBefore,\n    dynamic endAt,\n  }) {\n    CollectionReference collref = _db.collection(collection);\n    Query ref;\n    if (orderBy != null) {\n      orderBy.forEach((order) {\n        if (ref == null)\n          ref = collref.orderBy(order.field, descending: order.descending);\n        else\n          ref = ref.orderBy(order.field, descending: order.descending);\n      });\n    }\n    if (args != null) {\n      for (final arg in args) {\n        if (arg is QueryArgsV2) {\n          if (ref == null)\n            ref = collref.where(\n              arg.key,\n              isEqualTo: arg.isEqualTo,\n              isGreaterThan: arg.isGreaterThan,\n              isGreaterThanOrEqualTo: arg.isGreaterThanOrEqualTo,\n              isLessThan: arg.isLessThan,\n              isLessThanOrEqualTo: arg.isLessThanOrEqualTo,\n              isNull: arg.isNull,\n              arrayContains: arg.arrayContains,\n              arrayContainsAny: arg.arrayContainsAny,\n              whereIn: arg.whereIn,\n            );\n          else\n            ref = ref.where(\n              arg.key,\n              isEqualTo: arg.isEqualTo,\n              isGreaterThan: arg.isGreaterThan,\n              isGreaterThanOrEqualTo: arg.isGreaterThanOrEqualTo,\n              isLessThan: arg.isLessThan,\n              isLessThanOrEqualTo: arg.isLessThanOrEqualTo,\n              isNull: arg.isNull,\n              arrayContains: arg.arrayContains,\n              arrayContainsAny: arg.arrayContainsAny,\n              whereIn: arg.whereIn,\n            );\n        } else {\n          if (ref == null)\n            ref = collref.where(arg.key, isEqualTo: arg.value);\n          else\n            ref = ref.where(arg.key, isEqualTo: arg.value);\n        }\n      }\n    }\n    if (limit != null) {\n      if (ref == null)\n        ref = collref.limit(limit);\n      else\n        ref = ref.limit(limit);\n    }\n    if (startAfter != null && orderBy != null) {\n      ref = ref.startAfter([startAfter]);\n    }\n    if (startAt != null && orderBy != null) {\n      ref = ref.startAt([startAt]);\n    }\n    if (endAt != null && orderBy != null) {\n      ref = ref.endAt([endAt]);\n    }\n    if (endBefore != null && orderBy != null) {\n      ref = ref.endBefore([endBefore]);\n    }\n    if (ref != null)\n      return ref.snapshots().map((snap) =>\n          snap.docs.map((doc) => fromDS(doc.id, doc.data())).toList());\n    else\n      return collref.snapshots().map((snap) =>\n          snap.docs.map((doc) => fromDS(doc.id, doc.data())).toList());\n  }\n\n  /// Returns the list of documents from [from] date to [to] date matched by [field]\n  /// is ordered by the [field] provided.\n  /// additional [args] can be supplied to perform specific query.\n  Future<List<T>> getListFromTo(String field, DateTime from, DateTime to,\n      {List<QueryArgs> args = const []}) async {\n    var ref = _db.collection(collection).orderBy(field);\n    for (final arg in args) {\n      if (arg is QueryArgsV2) {\n        ref = ref.where(\n          arg.key,\n          isEqualTo: arg.isEqualTo,\n          isGreaterThan: arg.isGreaterThan,\n          isGreaterThanOrEqualTo: arg.isGreaterThanOrEqualTo,\n          isLessThan: arg.isLessThan,\n          isLessThanOrEqualTo: arg.isLessThanOrEqualTo,\n          isNull: arg.isNull,\n          arrayContains: arg.arrayContains,\n          arrayContainsAny: arg.arrayContainsAny,\n          whereIn: arg.whereIn,\n        );\n      } else {\n        ref = ref.where(arg.key, isEqualTo: arg.value);\n      }\n    }\n    QuerySnapshot query = await ref.startAt([from]).endAt([to]).get();\n    return query.docs.map((doc) => fromDS(doc.id, doc.data())).toList();\n  }\n\n  /// Returns the list of documents from [from] date to [to] date matched by [field] from [collection]\n  /// as a stream so that changes can be listened and is ordered by the [field] provided.\n  /// additional [args] can be supplied to perform specific query.\n  Stream<List<T>> streamListFromTo(String field, DateTime from, DateTime to,\n      {List<QueryArgs> args = const []}) {\n    var ref = _db.collection(collection).orderBy(field, descending: true);\n    for (final arg in args) {\n      if (arg is QueryArgsV2) {\n        ref = ref.where(\n          arg.key,\n          isEqualTo: arg.isEqualTo,\n          isGreaterThan: arg.isGreaterThan,\n          isGreaterThanOrEqualTo: arg.isGreaterThanOrEqualTo,\n          isLessThan: arg.isLessThan,\n          isLessThanOrEqualTo: arg.isLessThanOrEqualTo,\n          isNull: arg.isNull,\n          arrayContains: arg.arrayContains,\n          arrayContainsAny: arg.arrayContainsAny,\n          whereIn: arg.whereIn,\n        );\n      } else {\n        ref = ref.where(arg.key, isEqualTo: arg.value);\n      }\n    }\n    var query = ref.startAfter([to]).endAt([from]).snapshots();\n    return query.map(\n        (snap) => snap.docs.map((doc) => fromDS(doc.id, doc.data())).toList());\n  }\n\n  /// Creates new document based on the provided [item] and [id] in the [collection]\n  /// If [id] is null, [id] will be auto generated by firestore\n  ///\n  @Deprecated("Use create(Map<String,dynamic> data, {String id}) instead.")\n  Future<dynamic> createItem(T item, {String id}) {\n    if (id != null) {\n      return _db.collection(collection).doc(id).set(toMap(item));\n    } else {\n      return _db.collection(collection).add(toMap(item));\n    }\n  }\n\n  /// Creates new document based on the provided [data] and [id]  in the [collection]\n  /// If [id] is null, [id] will be auto generated by firestore\n  ///\n  Future<dynamic> create(Map<String, dynamic> data, {String id}) {\n    if (id != null) {\n      return _db.collection(collection).doc(id).set(data);\n    } else {\n      return _db.collection(collection).add(data);\n    }\n  }\n\n  ///\n  /// Updates the document with [id] with the provided [data] to the [collection]\n  ///\n  Future<void> updateData(String id, Map<String, dynamic> data) {\n    return _db.collection(collection).doc(id).update(data);\n  }\n\n  /// Removes item with [id] from [collection]\n  Future<void> removeItem(String id) {\n    return _db.collection(collection).doc(id).delete();\n  }\n}\n\n/// Supply query to query the data based on [key] field with [value]\n/// Always performs `isEqualTo` query\n@Deprecated("Use QueryArgsV2 instead")\nclass QueryArgs {\n  final dynamic key;\n  final dynamic value;\n\n  QueryArgs(this.key, this.value);\n}\n\n/// Supply query to query the collection based on [key] field and the\n/// values supplied to various arguments\n/// Please refer to firestore documentation for understanding\n/// various operators of the query\nclass QueryArgsV2 extends QueryArgs {\n  /// Field to match\n  final dynamic key;\n\n  /// performs equality == check\n  final dynamic isEqualTo;\n\n  /// performs less than < check\n  final dynamic isLessThan;\n\n  /// performs less than or equal to <= check\n  final dynamic isLessThanOrEqualTo;\n\n  /// performs greater than or equal to >= check\n  final dynamic isGreaterThanOrEqualTo;\n\n  /// performs greater than > check\n  final dynamic isGreaterThan;\n\n  /// performs array contains check\n  final dynamic arrayContains;\n\n  /// performs array contains any check\n  final List<dynamic> arrayContainsAny;\n\n  /// performs where in check\n  final List<dynamic> whereIn;\n\n  /// performs if is null check\n  final bool isNull;\n\n  /// Create instance of QueryArgsV2\n  QueryArgsV2(this.key,\n      {this.isEqualTo,\n      this.isLessThan,\n      this.isLessThanOrEqualTo,\n      this.isGreaterThan,\n      this.arrayContains,\n      this.arrayContainsAny,\n      this.whereIn,\n      this.isNull,\n      this.isGreaterThanOrEqualTo})\n      : super(key, isEqualTo);\n}\n\n/// Provide ordering option to queries\nclass OrderBy {\n  /// Field to order by\n  final String field;\n\n  /// Whether the order should be descending, default is false\n  final bool descending;\n\n  /// Creates instance of OrderBy\n  OrderBy(this.field, {this.descending = false});\n}\n')),Object(i.b)("p",null,"Below I will show how to use this package to get a list of ",Object(i.b)("inlineCode",{parentName:"p"},"Note")," items from ",Object(i.b)("inlineCode",{parentName:"p"},"notes")," collection."),Object(i.b)("h2",{id:"adding-dependency-and-importing"},"Adding Dependency and importing"),Object(i.b)("p",null,"First add it's dependency to the ",Object(i.b)("inlineCode",{parentName:"p"},"pubspec.yaml")," file."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-yaml"}),"dependencies:\n  firebase_helpers: latest\n")),Object(i.b)("p",null,"Then where you want to use it's methods, you can import it"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-dart"}),"import 'package:firebase_helpers/firebase_helpers';\n")),Object(i.b)("h2",{id:"create-a-model"},"Create a model"),Object(i.b)("p",null,"We create a notes item model for our data"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-dart"}),"class Note{\nfinal String title;\nfinal String id;\nfinal String description;\nfinal DateTime createdAt;\nfinal String userId;\n\nNote({this.title, this.id, this.description, this.createdAt, this.userId});\n\nNote.fromDS(String id, Map<String,dynamic> data):\n    id=id,\n    title=data['title'],\n    description=data['description'],\n    userId=data['user_id'],\n    createdAt=data['created_at']?.toDate();\n\nMap<String,dynamic> toMap() => {\n    \"title\":title,\n    \"description\":description,\n    \"created_at\": createdAt,\n    \"user_id\": userId,\n};\n}\n")),Object(i.b)("h2",{id:"instiantiate-database-service-with-specific-type"},"Instiantiate database service with specific type"),Object(i.b)("p",null,"We instantiate the generic class using the ",Object(i.b)("inlineCode",{parentName:"p"},"Note")," model as our type. Pass the collection path as ",Object(i.b)("inlineCode",{parentName:"p"},"notes")," and provide functions to convert from ",Object(i.b)("inlineCode",{parentName:"p"},"DocumentSnapshot")," to ",Object(i.b)("inlineCode",{parentName:"p"},"note")," and ",Object(i.b)("inlineCode",{parentName:"p"},"note")," to ",Object(i.b)("inlineCode",{parentName:"p"},"Map")),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-dart"}),'DatabaseService<Note> notesDb = DatabaseService<Note>("notes",fromDS: (id,data) =>  Note.fromDS(id,data), toMap:(note) => note.toMap() );\n')),Object(i.b)("h2",{id:"insert-new-item-to-firestore"},"Insert new item to firestore"),Object(i.b)("p",null,"Finally we can use ",Object(i.b)("inlineCode",{parentName:"p"},"notesDb")," instance to work with ",Object(i.b)("inlineCode",{parentName:"p"},"notes")," collection in our Firestore. For example to create item"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-dart"}),'Note note = Note(\n    title: "Hello Note",\n    description: "This is notes description",\n);\nnotesDb.create(note.toMap()); //this function will add our note item to the firestore database \n')),Object(i.b)("h2",{id:"github-repository"},"Github Repository"),Object(i.b)("p",null,Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/lohanidamodar/flutter_firebase_starter"}),"https://github.com/lohanidamodar/flutter_firebase_starter")))}c.isMDXComponent=!0}}]);