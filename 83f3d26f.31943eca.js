(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{88:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return d})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return p}));var i=n(2),o=n(6),a=(n(0),n(117)),d={slug:"decoding-flutter-build-context",title:"Understanding BuildContext in Flutter",tags:["flutter","nepali"]},r={permalink:"/blog/decoding-flutter-build-context",editUrl:"https://github.com/lohanidamodar/dlohani.com.np/edit/master/website/blog/blog/2021-12-15-decoding-flutter-build-context.md",source:"@site/blog/2021-12-15-decoding-flutter-build-context.md",description:"If you have been learning Flutter, you have seen BuildContext everywhere. BuildContext is an important concept in Flutter most developers find hard to understand. Many of even seasoned developers don't fully understand what BuildContext is and what it does. Yet it's basic and must know for every Flutter developers. Today in this article we will try to understand what BuildContext is and why it is important. Before we understand BuildContext, we must understand widget and widget tree. So let's dive into that.",date:"2021-12-15T00:00:00.000Z",tags:[{label:"flutter",permalink:"/blog/tags/flutter"},{label:"nepali",permalink:"/blog/tags/nepali"}],title:"Understanding BuildContext in Flutter",readingTime:5.185,truncated:!1,nextItem:{title:"Introduction to Linux Command Line",permalink:"/blog/intro-to-linux-command-line"}},l=[{value:"Widget Tree",id:"widget-tree",children:[]},{value:"BuildContext",id:"buildcontext",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],s={rightToc:l};function p(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(i.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"If you have been learning Flutter, you have seen BuildContext everywhere. BuildContext is an important concept in Flutter most developers find hard to understand. Many of even seasoned developers don't fully understand what BuildContext is and what it does. Yet it's basic and must know for every Flutter developers. Today in this article we will try to understand what BuildContext is and why it is important. Before we understand BuildContext, we must understand widget and widget tree. So let's dive into that."),Object(a.b)("h2",{id:"widget-tree"},"Widget Tree"),Object(a.b)("p",null,"In Flutter everything is a widget. Container, text, button, providers everything is virtually a widget. Also, a parent widgets can have one or more child widgets. Flutter applications consists of stack of widgets popularly known as the ",Object(a.b)("strong",{parentName:"p"},"widget tree"),". In the widget tree we connect parent and child widgets to show their relationship."),Object(a.b)("p",null,"If you have previously worked with frameworks like ReactJS, ViewJS or other component based frameworks, this is very similar. On frontend frameworks we have components, root component from where other components are sacked upon and each component is responsible for a unit of UI. So a ReactJS or ViewJS applications are a tree of components. In Flutter the components are rather called widgets but follows the similar principle. We have a root widget which is responsible for housing other widgets. So there is a parent-child relationship between widgets."),Object(a.b)("p",null,"A widget that renders another widget is a ",Object(a.b)("strong",{parentName:"p"},"parent widget")," and the widget that is rendered by the parent widget is called the ",Object(a.b)("strong",{parentName:"p"},"child widget"),". So if we have a root widget called ",Object(a.b)("inlineCode",{parentName:"p"},"MyApp")," which is the default in Flutter projects (but you can change it) it becomes the root in our widget tree."),Object(a.b)("p",null,"For example a tree could look like the following."),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{}),"            MyApp\n              |\n          MaterialApp\n              |\n           Scaffold\n              |\n        --------------\n        |            |\n      AppBar        Row\n                     |\n            ------------------\n            |                |\n          Text             TextButton\n")),Object(a.b)("p",null,"Here, we have ",Object(a.b)("inlineCode",{parentName:"p"},"MyApp")," as the root widget that is parent to all the widgets in the tree. This renders ",Object(a.b)("inlineCode",{parentName:"p"},"MaterialApp")," which renders ",Object(a.b)("inlineCode",{parentName:"p"},"Scaffold")," that renders ",Object(a.b)("inlineCode",{parentName:"p"},"AppBar")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Row"),". And finally ",Object(a.b)("inlineCode",{parentName:"p"},"Row")," renders ",Object(a.b)("inlineCode",{parentName:"p"},"Text")," and ",Object(a.b)("inlineCode",{parentName:"p"},"TextButton"),". We can go deeper and look into text and text button widgets but you get the point. So here we can say that ",Object(a.b)("inlineCode",{parentName:"p"},"MyApp")," is parent of ",Object(a.b)("inlineCode",{parentName:"p"},"MaterialApp")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Scaffold")," is parent of both ",Object(a.b)("inlineCode",{parentName:"p"},"AppBar")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Row")," widgets. Before we move on to understanding build context, keep in mind that every widget in a widget tree are in their own place. They have their own position, siblings, parent and child information. However the widget itself doesn't hold any of those information and that is where the BuildContext comes in. So let's dive into BuildContext."),Object(a.b)("h2",{id:"buildcontext"},"BuildContext"),Object(a.b)("p",null,"From the ",Object(a.b)("a",Object(i.a)({parentName:"p"},{href:"https://api.flutter.dev/flutter/widgets/BuildContext-class.html"}),"API docs"),", BuildContext is a handle to the location of a widget in a widget tree. Every widget in a widget tree has their own unique BuildContext which they receive in their build method. This means that BuildContext of a widget is not same as the BuildContext of the widget returned by the widget from the build method. In our widget tree example above, the BuildContext of MyApp is different from that of MaterialApp and BuildContext of MaterialApp is not the same as the BuildContext of Scaffold. Each widget in the widget tree have their own unique BuildContext."),Object(a.b)("p",null,"If we look into the source code of Flutter, for example into ",Object(a.b)("inlineCode",{parentName:"p"},"StatelessWidget"),", we can see a ",Object(a.b)("inlineCode",{parentName:"p"},"createElement")," method that creates an instance of ",Object(a.b)("inlineCode",{parentName:"p"},"StatelessElement")," passing ",Object(a.b)("inlineCode",{parentName:"p"},"this")," widget as parameter. "),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-dart"}),"// StatelessWidget\nStatelessElement createElement() => StatelessElement(this);\n")),Object(a.b)("p",null,"And if we look into ",Object(a.b)("inlineCode",{parentName:"p"},"StatelessElement"),", it passes it's own instance to the widgets build method."),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-dart"}),"class StatelessElement extends ComponentElement {\n  StatelessElement(StatelessWidget widget) : super(widget);\n\n  @override\n  Widget build() => widget.build(this);\n}\n")),Object(a.b)("p",null,"If we keep exploring more, we can see that ",Object(a.b)("inlineCode",{parentName:"p"},"ComponentElement")," extends ",Object(a.b)("inlineCode",{parentName:"p"},"Element")," which implements ",Object(a.b)("inlineCode",{parentName:"p"},"BuildContext")," class. So we can see that the element instance is what comes as ",Object(a.b)("inlineCode",{parentName:"p"},"BuildContext")," to every widget's build method."),Object(a.b)("p",null,"So from this, as every widget in widget tree is created by build method, and the build method receives this BuildContext. This helps the build method to find which widget it is going to draw and to locate the position of the widget to be drawn in the widget tree."),Object(a.b)("p",null,"Also, note that the widgets are only visible to their own BuildContext or to the BuildContext of their parent. That is wy, we can locate the parent widget from a child widget using ",Object(a.b)("inlineCode",{parentName:"p"},"findAncestorWidgetOfExactType")," helper method from BuildContext. This method is used to locate a widget of particular type in the widget tree. Going up the widget tree from whichever widget it was called, this method will try to locate the first widget that matches the type passed to the method."),Object(a.b)("p",null,"For example, we have a tree ",Object(a.b)("inlineCode",{parentName:"p"},"MyApp-> Scaffold -> Row -> Container -> Row -> Text"),". And we call the following method from the ",Object(a.b)("inlineCode",{parentName:"p"},"Text")," widget."),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{}),"context.findAncestorWidgetOfExactType(Row)\n")),Object(a.b)("p",null,"This will traverse up the tree starting from ",Object(a.b)("inlineCode",{parentName:"p"},"Text")," widget and stopping when a widget of type ",Object(a.b)("inlineCode",{parentName:"p"},"Row")," is located. So, the Row between ",Object(a.b)("inlineCode",{parentName:"p"},"Text")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Container")," will be returned. Next time you are using ",Object(a.b)("inlineCode",{parentName:"p"},"Navigator.of(context)")," or ",Object(a.b)("inlineCode",{parentName:"p"},"Scaffold.of(context)")," remember these are just helper method that use ",Object(a.b)("inlineCode",{parentName:"p"},"context.findAncestorWidgetOfExactType")," to find the nearest ",Object(a.b)("inlineCode",{parentName:"p"},"NavigatorState")," or ",Object(a.b)("inlineCode",{parentName:"p"},"ScaffoldState")," respectively."),Object(a.b)("p",null,"One thing to be careful while using BuildContext is that we must always verify the context that we are using in the method is the same context that is needed. For example, using ",Object(a.b)("inlineCode",{parentName:"p"},"Theme.of(context)")," looks for nearest Theme. If a nearest widget ",Object(a.b)("strong",{parentName:"p"},"X")," has a Theme in it's returned widget tree and it's calling Theme.of passing it's on context, then the Theme that is found will not be the Theme present in the build method but rather a Theme that was an ancestor to the widget ",Object(a.b)("strong",{parentName:"p"},"X"),". That is why we could use a ",Object(a.b)("inlineCode",{parentName:"p"},"Builder")," widget and it's context as the context received there is the context of ",Object(a.b)("inlineCode",{parentName:"p"},"Builder")," hence we can get the Theme that is ancestor to Builder but is in the same widget ",Object(a.b)("strong",{parentName:"p"},"X"),"."),Object(a.b)("h2",{id:"conclusion"},"Conclusion"),Object(a.b)("p",null,"With this I hope you understand what BuildContext is and how crucial it is in order to understand how Flutter works. This deepens our knowledge of the framework which helps us to build robust applications confidently. "))}p.isMDXComponent=!0}}]);